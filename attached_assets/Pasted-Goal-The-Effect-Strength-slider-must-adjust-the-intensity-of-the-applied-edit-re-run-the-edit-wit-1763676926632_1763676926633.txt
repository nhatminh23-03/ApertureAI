Goal:

The Effect Strength slider must adjust the intensity of the applied edit (re-run the edit with scaled parameters), not blend original↔edited.

The edited image must always keep the exact width & height of the original so the edited sits pixel-perfect on top of the original for comparison.

When a user picks an AI suggestion and “Refine Current Edit” toggle is ON, the app must use the edited image + current effectStrength as the new input (not the original).

The before/after view uses a center vertical slider (left=original, right=edited) with perfect alignment.

API Contract (update backend & client)

POST /execute

{
  "image_id": "<source-image-id>",      // original OR last edited, depending on refine toggle
  "steps": [ { "op": "tone", "params": { "prompt": "...", "effect_strength": 0.0..1.0 } } ],
  "keep_size_of": "<original-image-id>" // enforce same W×H as the very first image
}


Behavior:

Recompute the edit using effect_strength to scale the transform (e.g., guidance scale, LUT intensity, color curve amount, diffusion strength).

Always return an image with the same W×H as keep_size_of (resize/canvas pad as needed).

Return:

{ "image_id": "<new-edited-id>", "width": N, "height": M, "preview_url": "/data/<id>.png" }


POST /regenerate (optional alias) performs the same as /execute.

Frontend State Rules

Keep two ids in state:

const [originalId, setOriginalId] = useState<string>(); // first upload, never changes
const [currentId, setCurrentId]   = useState<string>(); // points to latest edited OR original
const [effectStrength, setEffectStrength] = useState<number>(0.5);
const [refineFromEdited, setRefineFromEdited] = useState<boolean>(true);


When user taps Regenerate or selects an AI suggestion:

sourceId = refineFromEdited ? currentId : originalId

call /execute with:

body = {
  image_id: sourceId,
  steps: [{ op: "tone", params: { prompt, effect_strength: effectStrength } }],
  keep_size_of: originalId
}


On success: setCurrentId(res.image_id)

Before/After slider always uses:

Left image URL = /data/${originalId}.png

Right image URL = /data/${currentId}.png

Render both inside the same fixed container size, CSS: object-fit: contain; width:100%; height:100%; and lock canvas dimensions to original’s aspect ratio.

UI/Code Tasks (make these atomic PR items)

Effect Strength = true edit intensity

Wire slider to re-invoke /execute with updated effect_strength. (Debounce 250–400ms.)

Remove any opacity cross-fade; show processing spinner while recomputing.

Same-size guarantee

Backend: after generating, force canvas to original W×H. If model returns a different size, resize or place onto a transparent canvas.

Add response fields width, height; assert on client that both images render in one container.

Refine Current Edit toggle

If ON: use currentId as image_id for the next generation.

If OFF: use originalId.

Ensure AI Suggestions respect this same rule.

Before/After slider

Use a library (e.g., react-compare-slider) or custom mask to reveal original vs edited.

Default position 50%. Keep alignment pixel-perfect.

Fix “Image not found” between History → Editor

Persist { originalId, currentId } in URL params or state storage (e.g., query ?id= or sessionStorage).

When mounting Editor, if ids are present, fetch/validate; otherwise redirect gracefully.

Ensure server doesn’t delete temp files referenced by history.

Crop policy

Only crop when prompt mentions crop. Otherwise never change framing. Backend should ignore model’s crop unless explicitly requested.